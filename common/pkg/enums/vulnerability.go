package enums

import (
	"strings"
)

// AccessType represents the access vector for a vulnerability
type AccessType string

const (
	AccessTypeNetwork         AccessType = "NETWORK"
	AccessTypeAdjacentNetwork AccessType = "ADJACENT_NETWORK"
	AccessTypeLocal           AccessType = "LOCAL"
	AccesTypePhysical         AccessType = "PHYSICAL"
	AccessTypeUnknown         AccessType = "UNKNOWN"
)

func (a AccessType) String() string {
	return string(a)
}

// ParseAccessType converts a string to AccessType
func ParseAccessType(s string, defaultVal AccessType) AccessType {
	val := AccessType(strings.ToUpper(s)) // Normalize input
	switch val {
	case AccessTypeNetwork, AccessTypeAdjacentNetwork, AccessTypeLocal, AccesTypePhysical: // Corrected const name
		return val
	default:
		return defaultVal
	}
}

// ComplexityType represents the attack complexity of a vulnerability
type ComplexityType string

const (
	ComplexityTypeLow     ComplexityType = "LOW"
	ComplexityTypeMedium  ComplexityType = "MEDIUM"
	ComplexityTypeHigh    ComplexityType = "HIGH"
	ComplexityTypeUnknown ComplexityType = "UNKNOWN"
)

func (c ComplexityType) String() string {
	return string(c)
}

// ParseComplexityType converts a string to ComplexityType
func ParseComplexityType(s string, defaultVal ComplexityType) ComplexityType {
	val := ComplexityType(strings.ToUpper(s))
	switch val {
	case ComplexityTypeLow, ComplexityTypeHigh:
		return val
	default:
		return defaultVal
	}
}

// PrivilegesRequiredType represents the privileges required to explouit a vulnerability
type PrivilegesRequiredType string

const (
	PrivilegesRequiredNone    PrivilegesRequiredType = "NONE"
	PrivilegesRequiredLow     PrivilegesRequiredType = "LOW"
	PrivilegesRequiredHigh    PrivilegesRequiredType = "HIGH"
	PrivilegesRequiredUnknown PrivilegesRequiredType = "UNKNOWN"
)

func (p PrivilegesRequiredType) String() string {
	return string(p)
}

// ParsePrivilegesRequiredType converts a string to PrivilegesRequiredType.
func ParsePrivilegesRequiredType(s string, defaultVal PrivilegesRequiredType) PrivilegesRequiredType {
	val := PrivilegesRequiredType(strings.ToUpper(s))
	switch val {
	case PrivilegesRequiredNone, PrivilegesRequiredLow, PrivilegesRequiredHigh:
		return val
	default:
		return defaultVal
	}
}

// SeverityType represents the base severity of a vulnerability.
type SeverityType string

const (
	SeverityTypeCritical SeverityType = "CRITICAL"
	SeverityTypeHigh     SeverityType = "HIGH"
	SeverityTypeMedium   SeverityType = "MEDIUM"
	SeverityTypeLow      SeverityType = "LOW"
	SeverityTypeNone     SeverityType = "NONE"
	SeverityTypeUnknown  SeverityType = "UNKNOWN"
)

func (s SeverityType) String() string {
	return string(s)
}

func (s SeverityType) Int() int {
	switch s {
	case SeverityTypeNone:
		return 0
	case SeverityTypeLow:
		return 1
	case SeverityTypeMedium:
		return 2
	case SeverityTypeHigh:
		return 3
	case SeverityTypeCritical:
		return 4
	default:
		return 0
	}
}

// ParseSeverityType converts a string to SeverityType.
func ParseSeverityType(s string, defaultVal SeverityType) SeverityType {
	val := SeverityType(strings.ToUpper(s))
	switch val {
	case SeverityTypeCritical, SeverityTypeHigh, SeverityTypeMedium, SeverityTypeLow, SeverityTypeNone:
		return val
	default:
		return defaultVal
	}
}

// ImpactType represents the impact on confidentiality, integrity, or availability.
type ImpactType string

const (
	ImpactTypeHigh    ImpactType = "HIGH"
	ImpactTypeLow     ImpactType = "LOW"
	ImpactTypeNone    ImpactType = "NONE"
	ImpactTypeUnknown ImpactType = "UNKNOWN"
)

func (i ImpactType) String() string {
	return string(i)
}

func (i ImpactType) Float64() float64 {
	switch i {
	case ImpactTypeHigh:
		return 1.0
	case ImpactTypeLow:
		return 0.5
	case ImpactTypeNone:
		return 0.1
	default:
		return 0.0
	}
}

// ParseImpactType converts a string to ImpactType.
func ParseImpactType(s string, defaultVal ImpactType) ImpactType {
	val := ImpactType(strings.ToUpper(s))
	switch val {
	case ImpactTypeHigh, ImpactTypeLow, ImpactTypeNone:
		return val
	default:
		return defaultVal
	}
}

// ExploitabilityType represents how exploitable the vulnerability is.
type ExploitabilityType string

const (
	ExploitabilityTypeUnproven       ExploitabilityType = "UNPROVEN"
	ExploitabilityTypeProofOfConcept ExploitabilityType = "PROOF_OF_CONCEPT"
	ExploitabilityTypeFunctional     ExploitabilityType = "FUNCIONAL"
	ExploitabilityTypeHigh           ExploitabilityType = "HIGH"
	ExploitabilityTypeNotDefined     ExploitabilityType = "NOT_DEFINED"
	ExploitabilityTypeUnknown        ExploitabilityType = "UNKNOWN"
)

func (e ExploitabilityType) String() string {
	return string(e)
}

// ParseExploitabilityType converts a string to ExploitabilityType.
func ParseExploitabilityType(s string, defaultVal ExploitabilityType) ExploitabilityType {
	val := ExploitabilityType(strings.ToUpper(strings.ReplaceAll(s, " ", "_"))) // Normalize common inputs
	switch val {
	case ExploitabilityTypeUnproven, ExploitabilityTypeProofOfConcept, ExploitabilityTypeFunctional, ExploitabilityTypeHigh, ExploitabilityTypeNotDefined:
		return val
	default:
		// Try direct match if normalization failed
		directMatch := ExploitabilityType(s)
		switch directMatch {
		case ExploitabilityTypeUnproven, ExploitabilityTypeProofOfConcept, ExploitabilityTypeFunctional, ExploitabilityTypeHigh, ExploitabilityTypeNotDefined:
			return directMatch
		}
		return defaultVal
	}
}

// LikelyhoodType refers to the probability that a vulnerability will be exploited.
type LikelyhoodType string

const (
	LikelyhoodTypeVeryHigh LikelyhoodType = "VERY_HIGH"
	LikelyhoodTypeHigh     LikelyhoodType = "HIGH"
	LikelyhoodTypeMedium   LikelyhoodType = "MEDIUM"
	LikelyhoodTypeLow      LikelyhoodType = "LOW"
	LikelyhoodTypeUnknown  LikelyhoodType = "UNKNOWN"
)

func (l LikelyhoodType) String() string {
	return string(l)
}

func (l LikelyhoodType) Float64() float64 {
	switch l {
	case LikelyhoodTypeVeryHigh:
		return 1.0
	case LikelyhoodTypeHigh:
		return 0.8
	case LikelyhoodTypeMedium:
		return 0.5
	case LikelyhoodTypeLow:
		return 0.2
	default:
		return 0.0
	}
}

func ParseLikelyhoodType(s string, defaultVal LikelyhoodType) LikelyhoodType {
	val := LikelyhoodType(strings.ToUpper(strings.ReplaceAll(s, " ", "_")))
	switch val {
	case LikelyhoodTypeVeryHigh, LikelyhoodTypeHigh, LikelyhoodTypeMedium, LikelyhoodTypeLow:
		return val
	default:
		return defaultVal
	}
}

// CalculateRiskScore is a simple function of likelihood and impact.
// It is a starting point and embodies a basic principle of risk calculation from
// NIST 800-30. It uses a conservative approach by selecting the impactScore as
// the higher of the two integrity and availability impact values, focusing on
// the worst case scenario.
func CalculateRiskScore(
	likelihood LikelyhoodType,
	integrityImpact ImpactType,
	availabilityImpact ImpactType,
) float64 {
	likelihoodScore := likelihood.Float64()
	impactScore := max(integrityImpact, availabilityImpact).Float64()

	riskScore := likelihoodScore * impactScore
	return riskScore
}
